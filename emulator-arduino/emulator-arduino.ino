#include "config.h"
#include "uvm32.h"
#include "common/uvm32_common_custom.h"

// Precompiled binary program to print integers
// This code expects to print via CSR 0x13C (IOREQ_PRINTD in common/uvm32_common_custom.h)
uint8_t rom[] = {
    0x23, 0x26, 0x11, 0x00, 0xef, 0x00, 0x80, 0x00, 0x73, 0x50, 0x80, 0x13,
    0x37, 0xf6, 0xff, 0xff, 0xb7, 0x17, 0x00, 0x00, 0x37, 0xe7, 0xff, 0xff,
    0x13, 0x05, 0xf0, 0x01, 0xb7, 0x45, 0x00, 0x00, 0x13, 0x06, 0xd6, 0xcc,
    0x93, 0x86, 0x37, 0x33, 0x13, 0x07, 0x77, 0xe6, 0x93, 0x87, 0x37, 0xb3,
    0x13, 0x08, 0xa0, 0x00, 0x63, 0xcc, 0xc6, 0x06, 0x93, 0x08, 0x07, 0x00,
    0x63, 0xc2, 0xe7, 0x06, 0x93, 0x03, 0x00, 0x00, 0x13, 0x03, 0x00, 0x00,
    0x13, 0x0e, 0x00, 0x00, 0x93, 0x0e, 0x00, 0x00, 0x93, 0x02, 0x00, 0x02,
    0x13, 0x8f, 0x02, 0xfe, 0x63, 0x6e, 0xe5, 0x03, 0x33, 0x0f, 0x73, 0x00,
    0x63, 0xea, 0xe5, 0x03, 0x33, 0x8e, 0xce, 0x03, 0xb3, 0x0e, 0x73, 0x40,
    0x73, 0x50, 0x90, 0x13, 0x13, 0x5e, 0xbe, 0x40, 0xb3, 0x8e, 0x1e, 0x01,
    0x33, 0x0e, 0xce, 0x00, 0x33, 0x83, 0xde, 0x03, 0x13, 0x53, 0xc3, 0x00,
    0xb3, 0x03, 0xce, 0x03, 0x93, 0xd3, 0xc3, 0x00, 0x93, 0x82, 0x12, 0x00,
    0x6f, 0xf0, 0x5f, 0xfc, 0x73, 0x90, 0x02, 0x14, 0x93, 0x88, 0x18, 0x09,
    0xe3, 0xd2, 0x17, 0xfb, 0x73, 0x10, 0x08, 0x14, 0x13, 0x06, 0x96, 0x19,
    0xe3, 0xd8, 0xc6, 0xf8, 0x37, 0x05, 0x00, 0x80, 0x13, 0x05, 0x05, 0x0c,
    0x73, 0x10, 0xb5, 0x13, 0x67, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x00
};

// Create an identifier for our host handler
typedef enum {
    F_PRINTD,
    F_PRINTLN,
    F_PRINTC,
} f_code_t;

// Map VM ioreq IOREQ_PRINTD (0x13C) to F_PRINTD, tell VM to expect write of a U32
const uvm32_mapping_t env[] = {
    { IOREQ_PRINTD, F_PRINTD, IOREQ_TYP_U32_WR },
    { IOREQ_PRINTC, F_PRINTC, IOREQ_TYP_U32_WR },
    { IOREQ_PRINTLN, F_PRINTLN, IOREQ_TYP_BUF_TERMINATED_WR },
};

uvm32_state_t vmst;
uvm32_evt_t evt;
bool isrunning = false;
uint32_t led_time = 0;
bool led_state = false;

void setup(void) {
    Serial.begin(115200);
    pinMode(LED_BUILTIN, OUTPUT);
    isrunning = false;
}

void loop(void) {
    // flash LED rapidly to show main loop is still running
    if (millis() > led_time + 50) {
        digitalWrite(LED_BUILTIN, led_state);
        led_state = !led_state;
        led_time = millis();
    }

    if (isrunning) {
        uvm32_run(&vmst, &evt, 100);   // num instructions before vm considered hung

        switch(evt.typ) {
            case UVM32_EVT_END:
                isrunning = false;
            break;
            case UVM32_EVT_IOREQ:    // vm has paused to handle IOREQ
                switch((f_code_t)evt.data.ioreq.code) {
                    case F_PRINTD:
                        Serial.println(evt.data.ioreq.val.u32);
                    break;
                    case F_PRINTC:
                        Serial.print((char)evt.data.ioreq.val.u32);
                    break;
                    case F_PRINTLN:
                        for (int i=0;i<evt.data.ioreq.val.buf.len;i++) {
                            Serial.print((char)evt.data.ioreq.val.buf.ptr[i]);
                        }
                        Serial.println("");
                    break;
                }
            break;
            case UVM32_EVT_ERR:
                Serial.print("Error: ");
                Serial.println(evt.data.err.errstr);
                isrunning = false;
            break;
            case UVM32_EVT_YIELD:
            break;
        }
    } else {
        Serial.println("Starting VM");
        // setup vm
        uvm32_init(&vmst, env, sizeof(env) / sizeof(env[0]));
        uvm32_load(&vmst, rom, sizeof(rom));
        isrunning = true;
        delay(2000);
    }

    return 0;
}
